#!/usr/bin/python
from __future__ import print_function

import os.path
import os
import subprocess
import sys
import glob
import socket
import shutil
import uuid
import time

import argparse

def message(x, prefix='run-radiopadre: ', file=sys.stderr):
    print(prefix + x.format(**globals()), file=file)

def bye(x, code=1):
    message(x)
    sys.exit(code)

def shell(cmd):
    return subprocess.call(cmd.format(**globals()), shell=True)

# ports used when running inside a container
CONTAINER_PORTS = 11001, 11002, 11003
child_processes = []

DEFAULT_DOCKER_IMAGE = "osmirnov/radiopadre:latest"

parser = argparse.ArgumentParser(description="Runs radiopadre")

# parser.add_option("--port-query",type=int,metavar="N",
#                   help="looks for N unused ports and reports them. For internal use.");
parser.add_argument("--bootstrap", action="store_true",
                  help="automatically initialize radiopadre virtual environment, if missing.")
parser.add_argument("--reinstall", action="store_true",
                  help="reinstall radiopadre virtual environment before running.")
parser.add_argument("--remote", action="store_true",
                  help="runs script in remote mode. Normally used by run-remote-padre -- not to be invoked directly.")
parser.add_argument("-b","--browser", action="store_true",
                  help="open a browser session, even if running under ssh.")
parser.add_argument("-n","--no-browser",action="store_true",
                  help="do not open a browser session, even if running locally.")
parser.add_argument("--no-default",action="store_true",
                  help="do not create a default notebook automatically. Default is to create.")
parser.add_argument("-a", "--auto-load",action="store_true",
                  help="automatically load first notebook found, if none is given explicitly")
parser.add_argument("--no-casacore", action="store_true",
                  help="Ignore casacore installation errors, if bootstrapping.")
parser.add_argument("--no-js9", action="store_true",
                  help="Ignore JS9 installation errors, if bootstrapping.")
parser.add_argument("-d", "--docker", action="store_true",
                  help="Runs radiopadre via a Docker container")
parser.add_argument("-D", "--dev-docker", action="store_true",
                  help="Runs radiopadre via a Docker container, but uses the host-installed version of radiopadre inside it. For developers.")
parser.add_argument("--docker-image", type=str, default=DEFAULT_DOCKER_IMAGE,
                  help="Which Docker image to use. Default is %(default)s.")
parser.add_argument("--docker-pull", action="store_true",
                  help="Use dopcker pull to update the image from dockerhub.")
parser.add_argument("--verbose", action="store_true",
                  help="Enable verbose output.")
parser.add_argument("notebook", nargs="?",
                  help="notebook/dir to load, if given")

# internal switches used when running in container
parser.add_argument("--inside-container", type=str, metavar="<ports>", help=argparse.SUPPRESS)
parser.add_argument("--workdir", type=str, help=argparse.SUPPRESS)

options = parser.parse_args()

if options.dev_docker:
    options.docker = True

def make_dir(name):
    name = os.path.expanduser(name)
    if not os.path.exists(name):
        os.mkdir(name)
    return name

# if explicit notebook directory is given, change into it before doing anything else
if options.notebook:
    if not os.path.exists(options.notebook):
        bye("{} doesn't exist".format(options.notebook))
    if os.path.isdir(options.notebook):
        os.chdir(options.notebook)
        options.notebook = '.'
        LOAD_DIR = True
        LOAD_NOTEBOOK = None
    else:
        nbdir = os.path.dirname(options.notebook)
        if nbdir:
            os.chdir(nbdir)
        options.notebook = os.path.basename(options.notebook)
        LOAD_DIR = False
        LOAD_NOTEBOOK = options.notebook
else:
    LOAD_DIR = '.'
    LOAD_NOTEBOOK = None

# setup session ID. This will also be the Jupyter authentication token
# Inside the container, the parent script will pass it in
if options.inside_container:
    os.environ['RADIOPADRE_SESSION_ID'] = session_id = raw_input("Enter session ID").strip()
# Outside the container, pick a random one
else:
    os.environ['RADIOPADRE_SESSION_ID'] = session_id = uuid.uuid4().hex

# get radiopadre install directory. __file__ is RADIOPADRE/bin/run-radiopadre, so take the dirname twice
PADRE_PATH = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
# cache and shadow dir base
PADRE_WORKDIR = options.workdir or os.path.expanduser("~/.radiopadre")
os.environ['RADIOPADRE_SHADOW_HOME'] = PADRE_WORKDIR

# virtual environment
PADRE_VENV = "/.radiopadre/venv" if options.inside_container else PADRE_WORKDIR + "/venv"
os.environ["RADIOPADRE_VENV"] = PADRE_VENV

# target directory
ABSROOTDIR = ROOTDIR = os.path.abspath(os.getcwd())              # e.g. /home/other/path
# shadow of target directory
SHADOWDIR = PADRE_WORKDIR + ROOTDIR                 # e.g. ~/.radiopadre/home/other/path
if not os.path.exists(SHADOWDIR):
    os.system("mkdir -p {}".format(SHADOWDIR))

# make .radiopadre in target dir, or in shadow dir
cachedir = ABSROOTDIR+"/.radiopadre"
cachelink = SHADOWDIR + "/.radiopadre"
if os.access(ABSROOTDIR, os.W_OK):
    make_dir(cachedir)
    if not os.path.exists(cachelink):
        os.symlink(cachedir, cachelink)
else:
    if os.path.islink(cachelink):
        os.unlink(cachelink)
    make_dir(cachelink)

if not os.path.exists(cachelink):
    os.symlink(ABSROOTDIR+"/.radiopadre", cachelink)


JUPYTER_OPTS = [
    "notebook",
    "--ContentsManager.pre_save_hook=radiopadre_utils.notebook_utils._notebook_save_hook",
    "--ContentsManager.allow_hidden=True" ]

DEVZERO = open("/dev/zero")
DEVNULL = open("/dev/null", "w")

activation_script = os.path.join(PADRE_VENV, "bin/activate_this.py")
complete_cookie = os.path.join(PADRE_VENV, ".complete")

# Switch into virtualenv, unless we're using docker
if not options.docker:
    # See https://stackoverflow.com/questions/1871549/determine-if-python-is-running-inside-virtualenv
    if hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix):
        if sys.prefix == PADRE_VENV:
            message("Already running inside radiopadre virtual environment")
        else:
            bye("Can't run this script inside a non-radiopadre virtualenv. Please deactivate and rerun.")
    else:
        if os.path.exists(activation_script) and os.path.exists(complete_cookie) and not options.reinstall:
            message("Found radiopadre virtualenv in {PADRE_VENV}")
        elif options.bootstrap or options.reinstall:
            if options.reinstall:
                message("Will reinstall radiopadre virtualenv using install-radiopadre")
            else:
                message("Can't find complete radiopadre virtualenv, bootstrapping with install-radiopadre")
            if shell("{}/bin/install-radiopadre {} {} reinstall".format(PADRE_PATH,
                        "--no-casacore" if options.no_casacore else "",
                        "--no-js9" if options.no_js9 else "",
                    )):
                bye("Installation script failed")

        message("Activating the radiopadre virtualenv via {activation_script}")
        execfile(activation_script, dict(__file__=activation_script))

message("Welcome to Radiopadre!")
if options.docker:
    docker_image = options.docker_image
    if docker_image[0] == ":":
        docker_image = DEFAULT_DOCKER_IMAGE.split(":")[0] + docker_image
    message("  Using radiopadre Docker image {docker_image}")
    if options.docker_pull:
        message("  Calling docker pull to make sure the image is up-to-date.")
        message("  (This may take a few minutes if it isn't....)")
        subprocess.call("docker pull {}".format(docker_image), shell=True)

elif options.inside_container:
    message("  Running inside a container")
else:
    message("  Using radiopadre install at {PADRE_PATH}")
message("  Session ID/notebook token is '{}'".format(session_id))  # careful, this is read by run-remote-padre!

# directory where we were originally run
os.environ['RADIOPADRE_ABSROOTDIR'] = ABSROOTDIR

# check if a root directory needs to be faked
# if not, make .radiopadre workdir
if os.access(ROOTDIR, os.W_OK):
    os.environ['RADIOPADRE_SERVER_BASEDIR'] = ABSROOTDIR
    orig_rootdir = None
else:
    message("  Target is {ROOTDIR}, which is not user-writeable. Will use a shadow directory instead.")
    message("  Shadow directory is {SHADOWDIR}")
    orig_rootdir = ROOTDIR
    os.environ['RADIOPADRE_SERVER_BASEDIR'] = ROOTDIR = SHADOWDIR
    os.chdir(SHADOWDIR)

make_dir(".radiopadre")


#=== will we be starting a browser?

browser = False
if options.inside_container:
    message("  Running inside container -- not opening a browser")
elif os.environ.get("SSH_CLIENT"):
    message("You appear to have logged in via ssh")
    if options.browser:
        message("--browser is set so I will open a browser anyway")
        browser = True
    else:
        message("You're logged in via ssh, so I'm not opening a web browser for you.")
        message("Please manually browse to the URL printed by Jupyter below. You will probably want to employ ssh")
        message("port forwarding if you want to browse this notebook from your own machine.")
        browser = False
else:
    message("You appear to have a local session")
    if options.no_browser:
        message("--no-browser is set, jupyter notebook will not invoke a browser.")
        message("Please manually browse to the URL printed by Jupyter below.")
        browser = False
    else:
        message("Allowing jupyter notebook to open a web browser. Use --no-browser to disable this.")
        browser = True


#=== find unused ports for Jupyter & helpers

def find_unused_port (base,maxtries=1000):
    for i in range(maxtries):
        serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            serversocket.bind(("localhost", base))
            serversocket.close()
            return base
        except:
            base += 1
            continue
    return None

if options.inside_container:
    jupyter_port, helper_port, http_port = CONTAINER_PORTS
    message("Inside container, using fixed ports {} {} {}".format(jupyter_port, helper_port, http_port))
else:
    jupyter_port = find_unused_port(1024)
    helper_port  = find_unused_port(jupyter_port+1)
    http_port    = find_unused_port(helper_port+1)
    selected_ports = jupyter_port, helper_port, http_port
    message("Selected ports: {}:{}:{}".format(jupyter_port, helper_port, http_port))

# in remote mode, ask the user-side script to supply port numbers
# (these need to be given to radiopadre so it can form up paths properly)
if options.remote:
    forwarded_ports = raw_input("{Remote mode} please enter fowarded port numbers: ")
    userside_jupyter_port, userside_helper_port, userside_http_port = forwarded_ports.strip().split(" ", 2)
    # print userside_helper_port, userside_http_port
# if inside container, the userside port numbers are passed in as via --inside-container port1:port2
elif options.inside_container:
    userside_jupyter_port, userside_helper_port, userside_http_port = map(int, options.inside_container.split(":"))
# else running locally -- userside port are as is
else:
    userside_jupyter_port, userside_helper_port, userside_http_port = jupyter_port, helper_port, http_port


JUPYTER_OPTS += [
    "--NotebookApp.token='{}'".format(session_id),
    "--NotebookApp.custom_display_url='http://localhost:{}'".format(userside_jupyter_port)
]

#=== figure out whether we initialize or load a notebook

ALL_NOTEBOOKS = glob.glob("*.ipynb")

if orig_rootdir and not ALL_NOTEBOOKS:
    orig_notebooks = glob.glob(os.path.join(orig_rootdir, "*.ipynb"))
    if orig_notebooks:
        message("  No notebooks in shadow directory, will copy notebooks from target.")
        message("  Copying {} notebooks from {}".format(len(orig_notebooks), orig_rootdir))
        for nb in orig_notebooks:
            shutil.copyfile(nb, './' + os.path.basename(nb))
        ALL_NOTEBOOKS = glob.glob("*.ipynb")

message("  Available notebooks: " + " ".join(ALL_NOTEBOOKS))

LOAD_NOTEBOOK = None

if not options.inside_container:

    DEFAULT_NAME = "radiopadre-default.ipynb"

    if not ALL_NOTEBOOKS:
        if not options.no_default:
            message("  No notebooks: will create {DEFAULT_NAME}")
            LOAD_DIR = True
            import shutil
            shutil.copyfile(PADRE_PATH + "/notebooks/" + DEFAULT_NAME, DEFAULT_NAME)
        else:
            message("  No notebooks but --no-default given. Displaying directory only.")
            LOAD_DIR = True
            LOAD_NOTEBOOK = None
    else:
        if LOAD_NOTEBOOK:
            if LOAD_NOTEBOOK in ALL_NOTEBOOKS:
                message("  Will load {LOAD_NOTEBOOK} as requested.")
            else:
                message("  {LOAD_NOTEBOOK} not found. Displaying directory only.")
                LOAD_DIR = True
                LOAD_NOTEBOOK = None
        else:
            if options.auto_load:
                LOAD_NOTEBOOK = ALL_NOTEBOOKS[0]
                message("  Auto-loading {LOAD_NOTEBOOK}.")


if LOAD_NOTEBOOK:
    message("Browse to URL: http://localhost:{}/notebooks/{}?token={}".format(
        userside_jupyter_port, LOAD_NOTEBOOK, session_id))  # this is read by remote
if LOAD_DIR:
    message("Browse to URL: http://localhost:{}/?token={}".format(userside_jupyter_port, session_id))

# now we're ready to start the container
if options.docker:
    docker = subprocess.check_output("which docker", shell=True).strip()
    if not docker:
        bye("docker binary not found")

    docker_local = make_dir("~/.radiopadre/.docker-local")
    js9_tmp = make_dir("~/.radiopadre/.js9-tmp")

    container_name = "radiopadre-{}".format(uuid.uuid4().hex)
    docker_opts = [ docker, "run", "-i", "--rm", "--name", container_name, "-w", ABSROOTDIR,
                        "--user", "{}:{}".format(os.getuid(), os.getgid()),
                        "-e", "USER={}".format(os.environ["USER"]),
                        "-e", "HOME={}".format(os.environ["HOME"])
                  ]
    for port1, port2 in zip(selected_ports, CONTAINER_PORTS):
        docker_opts += [ "-p", "{}:{}/tcp".format(port1, port2)]
    # setup mounts for work dir and home dir, if needed
    homedir = os.path.expanduser("~")
    docker_opts += [
                     "-v", "{}:{}{}".format(ABSROOTDIR, ABSROOTDIR, ":ro" if orig_rootdir else ""),
                     "-v", "{}:{}".format(homedir, homedir),
                     # hides /home/user/.local, which if exposed, can confuse jupyter and ipython
                     "-v", "{}:{}/.local".format(docker_local, homedir),
                     # mount a writeable tmp dir for the js9 install -- needed by js9helper
                     "-v", "{}:/.radiopadre/venv/js9-www/tmp".format(js9_tmp)
    ]
    if options.dev_docker:
        docker_opts += [ "-v", "{}:/radiopadre".format(PADRE_PATH) ]
    # add image
    docker_opts += [ docker_image,
                     "/radiopadre/bin/run-radiopadre",
                     "--inside-container", "{}:{}:{}".format(
                                userside_jupyter_port, userside_helper_port, userside_http_port),
                     "--workdir", PADRE_WORKDIR,
                   ]
    # add arguments
    if options.verbose:
        docker_opts.append("--verbose")
    if options.no_default:
        docker_opts.append("--no-default")
    if options.notebook:
        docker_opts.append(options.notebook)

    message("Running {}".format(" ".join(docker_opts)))
    docker_process = subprocess.Popen(docker_opts,
                                      stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                      env=os.environ)

    # print session ID to script in container, as it expects it
    docker_process.stdin.write(session_id+"\n")


    # now go through this whole rigamarole of waiting for the container to report the notebook is started...
    import select
    poller = select.poll()
    poller.register(docker_process.stdout)
    poller.register(docker_process.stderr)
    fdlabels = { docker_process.stdout.fileno(): ("stdout", docker_process.stdout),
                 docker_process.stderr.fileno(): ("stderr", docker_process.stderr) }

    try:
        while True:
            fdlist = poller.poll()
            for fd, event in fdlist:
                if event & (select.POLLHUP | select.POLLERR):
                    break
                fname, fobj = fdlabels.get(fd)
                line = fobj.readline().strip()
                message("docker {}: {}".format(fname, line))
                if "Jupyter Notebook is running" in line:
                    # report URL back to remote
                    # start browser if requested
                    if browser:
                        message("notebook startup detected -- driving browser")
                        default_browser = os.environ.get("PADRE_BROWSER", "xdg-open")
                        if LOAD_NOTEBOOK:
                            subprocess.Popen([default_browser,
                                              "http://localhost:{}/notebooks/{}?token={}".format(jupyter_port, LOAD_NOTEBOOK, session_id)])
                        else:
                            subprocess.Popen([default_browser,
                                              "http://localhost:{}/?token={}".format(jupyter_port, session_id)])
    except BaseException as exc:
        if type(exc) is KeyboardInterrupt:
            message("Caught Ctrl+C, terminating docker processes -- give it a few seconds")
        else:
            message("Caught exception {}, terminating docker processes -- give it a few seconds".format(exc))
        docker_process.terminate()
        docker_process.wait()
        status = 1

    # try:
    #     # give the docker process the session ID
    #     docker_process.communicate(session_id+"\n\n\n")
    #     status = 0
    # except Exception as exc:
    #     message("Caught exception {}, terminating docker processes".format(exc))
    #     docker_process.terminate()
    #     docker_process.wait()
    #     status = 1

    if container_name in subprocess.check_output(["docker", "ps"]):
        message("Cleaning up container")
        try:
            subprocess.check_output(["docker", "rm", container_name, "--force"])
        except subprocess.CalledProcessError:
            pass
    message("Exiting")
    sys.exit(status)


# get hostname
os.environ["HOSTNAME"] = subprocess.check_output("/bin/hostname")

# get jupyter path
notebook_dir = subprocess.check_output("{PADRE_VENV}/bin/pip show jupyter| "
                                       "grep Location:|cut -d ':' -f 2".format(**globals()), shell=True).strip()
if not notebook_dir:
    raise subprocess.CalledProcessError("jupyter installation path not found")


# check status of JS9. Ends up being True, or a RuntimeError

js9dir = js9error = None
js9status_file = PADRE_VENV + "/js9status"
if not os.path.exists(js9status_file):
    js9error = "not found"
else:
    js9dir = open(js9status_file).read().strip()
    if not js9dir.startswith("/"):
        js9error = js9dir
        js9dir = None

os.environ['RADIOPADRE_JS9_DIR'] = js9dir or ''
os.environ['RADIOPADRE_JS9_ERROR'] = js9error or ''
if js9dir:
    message("  Found JS9 install in {js9dir}")
else:
    message("  Warning: JS9 not functional ({js9error}). Reinstall radiopadre?")


# # make link to JS9 install
# if js9dir:
#     if not os.path.exists(PADRE_WORKDIR + "/js9-www"):
#         os.symlink(js9dir, PADRE_WORKDIR + "/js9-www")
#     if not os.path.exists(PADRE_WORKDIR + "/js9colormaps.js"):
#         message("making {} symlink".format(PADRE_WORKDIR + "/js9colormaps.js"))
#         os.symlink(notebook_dir + "/notebook/static/js9colormaps.js", PADRE_WORKDIR + "/js9colormaps.js")
#     if not os.path.exists(PADRE_WORKDIR + "/radiopadre-www"):
#         os.symlink(PADRE_PATH + "/html", PADRE_WORKDIR + "/radiopadre-www")

# add padre directory to PYTHONPATH
if "PYTHONPATH" in os.environ:
    os.environ["PYTHONPATH"] = os.environ["PYTHONPATH"] + ":" + PADRE_PATH
else:
    os.environ["PYTHONPATH"] = PADRE_PATH



JUPYTER_OPTS.append("--port={}".format(jupyter_port))
if not browser:
    JUPYTER_OPTS += ["--no-browser", "--browser=/dev/null"] # --no-browser alone seems to be ignored

if options.inside_container:
    JUPYTER_OPTS += ["--allow-root", "--ip=0.0.0.0"] # --no-browser alone seems to be ignored

if LOAD_NOTEBOOK:
    JUPYTER_OPTS.append(LOAD_NOTEBOOK)

#os.environ['RADIOPADRE_SHADOW_URLBASE'] = urlbase = "http://localhost:{}/".format(forwarded_http_port)
os.environ['RADIOPADRE_SHADOW_URLBASE'] = urlbase = "http://localhost:{}/{}/".format(userside_http_port, session_id)
js9prefs = None

http_rewrites = [ "/radiopadre-www/={}/".format(PADRE_PATH + "/html") ]

if js9dir:
    os.environ['RADIOPADRE_JS9_HELPER_PORT'] = str(userside_helper_port)
    # create JS9 settings file for session
    js9prefs = ".radiopadre/js9prefs.js"
    open(js9prefs, "w").write(
        "JS9Prefs.globalOpts.helperPort = {};\n".format(userside_helper_port)
    )
    # URL to local settings file for this session
    os.environ['RADIOPADRE_JS9_DIR'] = "{}js9-www/".format(urlbase)
    os.environ['RADIOPADRE_JS9_SETTINGS'] = "{}{}/{}".format(urlbase, ABSROOTDIR.lstrip("/"), js9prefs)


    http_rewrites.append("/js9-www/={}/".format(js9dir))
    http_rewrites.append("/js9colormaps.js={}".format(notebook_dir + "/notebook/static/js9colormaps.js"))

try:
    helper_proc = None
    if js9dir:
        os.environ['JS9_LOCAL_URL_PREFIX'] = urlbase
        os.environ['JS9_LOCAL_FS_PREFIX'] = PADRE_WORKDIR + "/"
        js9helper = js9dir +"/js9Helper.js"
        if os.path.exists(js9helper):
            message("Starting {js9helper} on port {helper_port} in {SHADOWDIR}")
            try:
                nodejs = subprocess.check_output("which nodejs || which node", shell=True)
            except subprocess.CalledProcessError:
                nodejs = None
                bye("Unable to find nodejs or node -- can't run js9helper. You need to apt-get install nodejs perhaps?")
            try:
                os.chdir(SHADOWDIR)
                child_processes.append(subprocess.Popen([nodejs.strip(), js9helper,
                    ('{{"helperPort": {}, "debug": {}, ' +
                     '"fileTranslate": ["^(http://localhost:[0-9]+/[0-9a-f]+{}|/static/)", ""] }}').format(
                        helper_port, 1 if options.verbose else 0,
                        ABSROOTDIR)],
                    stdin=DEVZERO, stdout=sys.stdout, stderr=sys.stderr))
            finally:
                os.chdir(ROOTDIR)

    message("Starting HTTP server process in {PADRE_WORKDIR} on port {http_port}")
    args = [PADRE_VENV+"/bin/python", PADRE_PATH+"/bin/http_server.py", str(http_port) ] + http_rewrites

    try:
        os.chdir(PADRE_WORKDIR)
        child_processes.append(subprocess.Popen(args, stdin=DEVZERO,
                      stdout=sys.stdout if options.verbose else DEVNULL,
                      stderr=sys.stderr if options.verbose else DEVNULL))
    finally:
        os.chdir(ROOTDIR)

    ## start jupyter process

    jupyter_path = PADRE_VENV + "/bin/jupyter"
    message("Starting: "+jupyter_path+" "+" ".join(JUPYTER_OPTS))

    notebook_proc = subprocess.Popen([jupyter_path] + JUPYTER_OPTS,
                                      stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                      env=os.environ)

    ## use this instead to debug the sessison
    #notebook_proc = subprocess.Popen([PADRE_VENV+"/bin/ipython"],
    #                                 stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
    #                                  env=os.environ)

    child_processes.append(notebook_proc)

    notebook_proc.wait()
    message("Notebook process done")
    child_processes.pop(-1)

finally:
    message("Terminating child processes")
    for proc in child_processes:
        proc.terminate()
        proc.wait()

message("Exiting")