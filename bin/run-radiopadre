#!/usr/bin/python
from __future__ import print_function

import os.path
import os
import subprocess
import sys
import glob
import socket
import shutil
import uuid
import argparse
import re
import tempfile
import select

def message(x, prefix='run-radiopadre: ', file=sys.stderr):
    print(prefix + x.format(**globals()), file=file)

def bye(x, code=1):
    message(x)
    sys.exit(code)

def shell(cmd):
    return subprocess.call(cmd.format(**globals()), shell=True)

def make_dir(name):
    name = os.path.expanduser(name)
    if not os.path.exists(name):
        os.mkdir(name)
    return name

def find_unused_port (base,maxtries=1000):
    for i in range(maxtries):
        serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            serversocket.bind(("localhost", base))
            serversocket.close()
            return base
        except:
            base += 1
            continue
    return None

default_browser = os.environ.get("PADRE_BROWSER","xdg-open")

# default repo and branch to use when initializing a remote installation
REPO = "git@github.com:ratt-ru/radiopadre.git"
BRANCH = "master"

# ports used when running inside a container
CONTAINER_PORTS = 11001, 11002, 11003
child_processes = []

DEFAULT_DOCKER_IMAGE = "osmirnov/radiopadre:latest"

DEFAULT_BROWSER = os.environ.get("RADIOPADRE_BROWSER", "xdg-open")

parser = argparse.ArgumentParser(description="Runs radiopadre environment")

# parser.add_option("--port-query",type=int,metavar="N",
#                   help="looks for N unused ports and reports them. For internal use.");
parser.add_argument("--bootstrap", action="store_true",
                  help="automatically initialize radiopadre virtual environment, if missing.")
parser.add_argument("--reinstall", action="store_true",
                  help="reinstall radiopadre virtual environment before running.")
parser.add_argument("-b","--browser", action="store_true",
                  help="open a browser session, even if running under ssh.")
parser.add_argument("-n","--no-browser",action="store_true",
                  help="do not open a browser session, even if running locally.")
parser.add_argument("--browser-command", type=str, default=DEFAULT_BROWSER,
                  help="browser command to run. Default is %(default)s (can also set RADIOPADRE_BROWSER).")
parser.add_argument("--no-casacore", action="store_true",
                  help="Ignore casacore installation errors, if bootstrapping.")
parser.add_argument("--no-js9", action="store_true",
                  help="Ignore JS9 installation errors, if bootstrapping.")
parser.add_argument("--init-remote",action="store_true",
                  help="automatically initialize remote radiopadre installation and virtual environment, if missing. "
                       "Forces use of remote installation and not Docker, unless combined with -D flag.")
parser.add_argument("--remote-path",type=str,
                  help="directory in which remote radiopadre is installed. Default is to try ~/radiopadre first, "+
                       "and PATH second.")
parser.add_argument("-u","--update",action="store_true",
                      help="update remote radiopadre installation using git pull, or docker container using docker pull")
parser.add_argument("-d", "--docker", action="store_true",
                  help="Runs radiopadre via a Docker container")
parser.add_argument("-D", "--dev-docker", action="store_true",
                  help="Runs radiopadre via a Docker container, but uses the host-installed version of radiopadre inside it. For developers.")
parser.add_argument("--docker-image", type=str, default=DEFAULT_DOCKER_IMAGE,
                  help="Which Docker image to use. Default is %(default)s.")
parser.add_argument("--docker-pull", action="store_true",
                  help="Use docker pull to update the image from dockerhub.")
parser.add_argument("--no-default",action="store_true",
                  help="do not create a default notebook automatically. Default is to create.")
parser.add_argument("-a", "--auto-load",action="store_true",
                  help="automatically load first notebook found, if none is given explicitly")
parser.add_argument("--verbose", action="store_true",
                  help="Enable verbose output.")
parser.add_argument("destination", nargs="?",
                  help="notebook/directory to load, or remote_host:directory to run a remote radiopadre")
parser.add_argument("initial_notebook", nargs="?",
                  help="initial notebook to copy to remote host, if needed")

# internal switches used when running in container
parser.add_argument("--inside-container", type=str, metavar="<ports>", help=argparse.SUPPRESS)
parser.add_argument("--workdir", type=str, help=argparse.SUPPRESS)
# internal switch to run script in remote mode.
parser.add_argument("--remote", action="store_true", help=argparse.SUPPRESS)

options = parser.parse_args()

default_notebook_code = """{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### This is a very basic default radiopadre notebook to start you browsing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# execute this with Ctrl+Enter\n",
    "from radiopadre import ls, settings\n",
    "ls = ls()\n",
    "ls"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ls[0]"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "radiopadre",
   "language": "python",
   "name": "radiopadre"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.15rc1"
  },
  "radiopadre_notebook_scrub": true
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
"""

### REMOTE MODE
if options.destination and ':' in options.destination:
    host, notebook_path = options.destination.split(':', 1)

    if options.docker:
        if options.dev_docker:
            parser.error("Can't combine -d/--docker and -D/--dev-docker modes")
        if options.init_remote:
            parser.error("Can't combine -d/--docker and --init-remote modes")

    message("radiopadre: Will start remote radiopadre on {}:{}".format(host, notebook_path))

    # Find remote run-radiopadre script

    if options.remote_path:
        padre_execs = [ os.path.join(options.remote_path, "bin/run-radiopadre") ]
    else:
        padre_execs = [ os.path.join("~/radiopadre/bin/run-radiopadre"), "run-radiopadre" ]

    DEVZERO = open("/dev/zero")
    DEVNULL = open("/dev/null", "w")

    SSH_MUX_OPTS = "-o ControlPath=/tmp/ssh_mux_radiopadre_%C -o ControlMaster=auto -o ControlPersist=1h".split()

    SCP_OPTS = ["scp"] + SSH_MUX_OPTS
    SSH_OPTS = ["ssh","-tt"] + SSH_MUX_OPTS + [host]
    #SSH_OPTS = ["ssh"] + SSH_MUX_OPTS + [host]

    # master ssh connection, to be closed when we exit
    message("radiopadre: opening initial master connection to {} {}. You may be prompted for your password.".format(host, " ".join(SSH_OPTS)))
    ssh_master = subprocess.check_call(SSH_OPTS + ["exit"]) # stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)

    # raw_input("Continue?")

    def ssh_remote(command, fail_retcode=None, stderr=DEVNULL):
        """Runs command on remote host. Returns its output if the exit status is 0, or None if the exit status matches fail_retcode.

        Any other non-zero exit status (or any other error) will result in an exception.
        """
        try:
            return subprocess.check_output(SSH_OPTS+[command], stderr=stderr)
        except subprocess.CalledProcessError,exc:
            if exc.returncode == fail_retcode:
                return None
            raise

    def ssh_remote_interactive(command, fail_retcode=None, stderr=DEVNULL):
        """Runs command on remote host. Returns its output if the exit status is 0, or None if the exit status matches fail_retcode.

        Any other non-zero exit status (or any other error) will result in an exception.
        """
        try:
            return subprocess.check_call(SSH_OPTS+[command], stderr=stderr)
        except subprocess.CalledProcessError,exc:
            if exc.returncode == fail_retcode:
                return None
            raise

    def scp_to_remote(path, remote_path):
        return subprocess.check_output(SCP_OPTS+[path, "{}:{}".format(host, remote_path)])

    def check_remote_file(remote_file, test="-x"):
        """
        Checks that a remote file exists. 'test' is specified bash-style, e.g. "-x" for executable.
        Can also use -f and -f, for example.
        Returns True or False, or raises an exception on other errors.
        """
        return ssh_remote("if [ {} {} ]; then exit 0; else exit 199; fi".format(test, remote_file),
                                fail_retcode=199, stderr=DEVNULL) is not None

    def check_remote_command(command):
        """
        Checks that remote host has a particular command available.
        Returns True or False, or raises an exception on other errors.
        """
        return bool(ssh_remote("which "+command, fail_retcode=1, stderr=DEVNULL))

    # Check for various remote bits

    message("radiopadre: Checking installation on {}".format(host))
    has_venv = check_remote_command("virtualenv") and check_remote_command("pip")
    has_git = check_remote_command("git")
    has_docker = check_remote_command("docker")

    ## Look for remote launch script

    def help_yourself(problem, suggestion=None):
        message("radiopadre: {}".format(problem))
        message("radiopadre: Please ssh {} and sort it out yourself, then rerun this script".format(host))
        if suggestion:
            message("radiopadre: ({})".format(suggestion))
        sys.exit(1)

    bootstrap = False

    # look for remote installation, unless we're explicitly set to docker mode

    if not options.docker:
        for padre_exec in padre_execs:
            if check_remote_file(padre_exec):
                message("radiopadre: Found remote radiopadre launch script at {}:{}".format(host, padre_exec))
                if options.update:
                    padre_dir = os.path.dirname(os.path.dirname(padre_exec))
                    message("radiopadre: --update specified, will try a git pull in {}".format(padre_dir))
                    try:
                        ssh_remote("cd {} ; git checkout {}; git pull".format(padre_dir, BRANCH))
                    except subprocess.CalledProcessError as exc:
                        message(exc.output)
                        help_yourself("git pull failed with exit code {}".format(exc.returncode))
                break
        else:
            message("radiopadre: No run-radiopadre script found on {}".format(host))
            if options.init_remote:
                install_path = options.remote_path or "~/radiopadre"
                message("radiopadre: I could try to bootstrap a radiopadre installation into {}:{}".format(host, install_path))

                if not has_git:
                    help_yourself("However, I don't see git installed on {}".format(host),
                                  "Try 'sudo apt instal git' on {}".format(host))

                if check_remote_file(install_path, "-d"):
                    message("radiopadre: However, the directory {}:{} already exists, so I'd rather not!".format(host, install_path))
                    help_yourself("This may be a sign of a broken radiopadre installation on {},".format(host),
                                  "(For example, remove {}:{} to bootstrap from scratch.)".format(host, install_path))

                message("radiopadre: (command would be 'git clone -b {} {} radiopadre')".format(BRANCH, REPO))

                # try the bootstrap
                message("radiopadre: Cloning {}, branch {} into {}:~/radiopadre".format(REPO, BRANCH, host))
                ssh_remote_interactive("git clone -b {} {} radiopadre".format(BRANCH, REPO))
                padre_exec = os.path.join(install_path, "bin/run-radiopadre")
                if not check_remote_file(padre_exec):
                    help_yourself("git clone ran, but I still don't see the launch script {}:{}".format(host, padre_exec))
                message("radiopadre: Success! Running remote in bootstrap mode")
                bootstrap = True
            elif options.dev_docker:
                message("radiopadre: no remote installation detected and --init-remote not given: can't run -D/--dev-docker mode")
                sys.exit(1)
            else:
                message("radiopadre: no remote installation detected, falling back to Docker mode")
                options.docker = True

    # look for remote virtualenv, unless we're in docker mode

    if not options.docker:
        ## Check for remote virtualenv
        remote_venv = "~/.radiopadre/venv"
        if not options.reinstall and check_remote_file(remote_venv + "/.complete", "-f"):
            activate_script = "{}/bin/activate".format(remote_venv)
            message("radiopadre: Testing the remote virtual environment at {}:{}".format(host, remote_venv))
            try:
                ssh_remote("source {}".format(activate_script))
            except subprocess.CalledProcessError,exc:
                message(exc.output)
                help_yourself("The remote virtual environment at {}:{} exists, but we can't seem to activate it".format(host, remote_venv),
                              "Perhaps remove {}:{}, and I'll try to rebuild it from scratch.".format(host, remote_venv))
        else:
            if options.init:
                if options.reinstall:
                    message("radiopadre: --reinstall given, will reinstall remote virtual environment")
                else:
                    message("radiopadre: Missing or incomplete remote virtual environment at {}:{}, but I can create it".format(host, remote_venv))
                if not has_venv:
                    help_yourself("However, I don't see virtualenv and/or pip installed on {}".format(host),
                                  "Try 'sudo apt instal virtualenv pip' on {}".format(host))

                if bootstrap and not options.reinstall:
                    message("radiopadre: Since we're bootstrapping a new installation, I will proceed to do so")

                bootstrap = True
            else:
                message("radiopadre: no remote virtual environment detected, falling back to Docker mode")
                options.docker = True

    # copy notebook to remote
    if options.initial_notebook:
        if not os.path.exists(options.initial_notebook):
            bye("{} doesn't exist".format(options.initial_notebook))
        if check_remote_file(notebook_path or ".", "-d"):
            nbpath = "{}/{}".format(notebook_path or ".", options.initial_notebook)
            if check_remote_file(nbpath, "-f"):
                message("radiopadre: remote notebook {nbpath} exists, will not copy over")
            else:
                message("radiopadre: remote notebook {nbpath} doesn't exist, will copy over")
                scp_to_remote(options.initial_notebook, notebook_path)
            notebook_path = nbpath

    # run remote in docker mode
    if options.docker:
        if not has_docker:
            help_yourself("{} doesn't appear to have Docker installed.".format(host),
                          "Ask the admin to install Docker on {} and to add you to the docker group. Otherwise, use "
                          "-i/--init to run radiopadre in remote installation mode.".format(host))

        message("radiopadre: copying run script and default notebook to {}:.radiopadre/tmp".format(host))
        ssh_remote("mkdir -p ~/.radiopadre/tmp/bin ~/.radiopadre/tmp/notebooks")
        scp_to_remote(__file__, ".radiopadre/tmp/bin")
        tmpfile = tempfile.NamedTemporaryFile()
        tmpfile.file.write(default_notebook_code)
        tmpfile.file.flush()
        scp_to_remote(tmpfile.name, ".radiopadre/tmp/notebooks")
        tmpfile = None
        padre_exec = "~/.radiopadre/tmp/bin/run-radiopadre -d --docker-image " + options.docker_image
        if options.update:
            padre_exec += " --docker-pull"

    elif options.dev_docker:
        padre_exec += " -D --docker-image " + options.docker_image
        if options.update:
            padre_exec += " --docker-pull"

    if bootstrap:
        padre_exec += " --bootstrap"
    if options.reinstall:
        padre_exec += " --reinstall"
    if options.no_casacore:
        padre_exec += " --no-casacore"
    if options.no_js9:
        padre_exec += " --no-js9"
    if options.verbose:
        padre_exec += " --verbose"

    padre_exec += "  --remote " + notebook_path

    # start ssh subprocess to launch notebook
    args = list(SSH_OPTS) + [padre_exec]

    ssh = subprocess.Popen(args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    # poll stdout/stderr
    poller = select.poll()
    fdlabels = {}

    def register_process (po, label=""):
        poller.register(po.stdout)
        poller.register(po.stderr)
        fdlabels[po.stdout.fileno()] = '{} {}'.format(host, label), po.stdout
        fdlabels[po.stderr.fileno()] = '{} {} stderr'.format(host, label), po.stderr

    register_process(ssh,"ssh")

    ssh2 = None
    local_ports = []
    remote_ports = None
    session_id = None
    urls = []
    remote_running = False

    while True:
        try:
            fdlist = poller.poll()
            for fd,event in fdlist:
                line = None
                if event & (select.POLLHUP|select.POLLERR):
                    message("radiopadre: ssh to {} complete, exiting".format(host))
                    sys.exit(0)
                # which fd is ready? read line and message(it)
                label,fobj = fdlabels.get(fd)
                line = fobj.readline().strip()
                #if fobj is not ssh.stderr:
                print("\r{}: {}\r".format(label,line))
                if not line:
                    continue
                # if remote is not yet started, check output
                if not remote_running:
                    # check for session ID
                    match = re.match(".*Session ID/notebook token is '([0-9a-f]+)'", line)
                    if match:
                        session_id = match.group(1)
                    # check for notebook port, and launch second ssh when we have it
                    match = re.match(".*Selected ports: ([\d]+):([\d]+):([\d]+)[\s]*$",line)
                    if match:
                        remote_jupyter_port, remote_js9helper_port, remote_http_port = remote_ports = match.groups()
                        message("radiopadre: Detected remote ports %s:%s:%s\r" % tuple(remote_ports))

                        ssh2_args = ["ssh"] + SSH_MUX_OPTS + ["-O", "forward", host]
                        local_ports = []
                        starting_local_port = 10000+os.getuid()
                        for remoteport in remote_ports:
                            # find unused local port
                            localport = find_unused_port(starting_local_port)
                            local_ports.append(localport)
                            starting_local_port = localport+1
                            message("radiopadre: remote port %s, selecting local port %s\r" % (remoteport, localport))
                            ssh2_args += [ "-L", "localhost:%s:localhost:%s" % (localport, remoteport) ]
                        # start second ssh process to forward the port
                        message("radiopadre: sending forward request to ssh mux process".format(ssh2_args))
                        subprocess.call(ssh2_args)

                        # tell first ssh process the ports we have selected
                        message("radiopadre: Passing local port assignments to remote end")
                        ssh.stdin.write("{} {} {}\n".format(*local_ports))

                    # check for launch URL
                    match = re.match(".*Browse to URL: ([^\s]+)", line)
                    if match:
                        urls.append(match.group(1))

                    if "The Jupyter Notebook is running at" in line:
                        remote_running = True
                        for url in urls:
                            # open browser if needed
                            if not options.no_browser:
                                message("radiopadre: Opening browser for {}\r".format(url))
                                subprocess.Popen([options.browser_command, url])
                            else:
                                message("-n/--no-browser given, not opening a browser for you\r")
                                message("Please surf to {}\n".format(url))
        except KeyboardInterrupt:
            message("radiopadre: Ctrl+C caught")
    #        message("radiopadre: sending exit request to ssh mux process...")
    #        raw_input("Continue?")
    #        subprocess.call(SSH_OPTS + ["-O", "exit", host])
    #        raw_input("Sent. Continue?")
            message("radiopadre: killing main ssh process...")
            ssh.kill()

    os.system("reset")
    sys.exit(0)


if options.dev_docker:
    options.docker = True

# if explicit notebook directory is given, change into it before doing anything else
if options.destination:
    if not os.path.exists(options.destination):
        bye("{} doesn't exist".format(options.destination))
    if os.path.isdir(options.destination):
        os.chdir(options.destination)
        options.destination = '.'
        LOAD_DIR = True
        LOAD_NOTEBOOK = None
    else:
        nbdir = os.path.dirname(options.destination)
        if nbdir:
            os.chdir(nbdir)
        options.destination = os.path.basename(options.destination)
        LOAD_DIR = False
        LOAD_NOTEBOOK = options.destination
else:
    LOAD_DIR = '.'
    LOAD_NOTEBOOK = None

# setup session ID. This will also be the Jupyter authentication token
# Inside the container, the parent script will pass it in
if options.inside_container:
    os.environ['RADIOPADRE_SESSION_ID'] = session_id = raw_input("Enter session ID").strip()
# Outside the container, pick a random one
else:
    os.environ['RADIOPADRE_SESSION_ID'] = session_id = uuid.uuid4().hex

# get radiopadre install directory. __file__ is RADIOPADRE/bin/run-radiopadre, so take the dirname twice
PADRE_PATH = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
# cache and shadow dir base
PADRE_WORKDIR = options.workdir or os.path.expanduser("~/.radiopadre")
os.environ['RADIOPADRE_SHADOW_HOME'] = PADRE_WORKDIR

# virtual environment
PADRE_VENV = "/.radiopadre/venv" if options.inside_container else PADRE_WORKDIR + "/venv"
os.environ["RADIOPADRE_VENV"] = PADRE_VENV

# target directory
ABSROOTDIR = ROOTDIR = os.path.abspath(os.getcwd())              # e.g. /home/other/path
# shadow of target directory
SHADOWDIR = PADRE_WORKDIR + ROOTDIR                 # e.g. ~/.radiopadre/home/other/path
if not os.path.exists(SHADOWDIR):
    os.system("mkdir -p {}".format(SHADOWDIR))

# make .radiopadre in target dir, or in shadow dir
cachedir = ABSROOTDIR+"/.radiopadre"
cachelink = SHADOWDIR + "/.radiopadre"
if os.access(ABSROOTDIR, os.W_OK):
    make_dir(cachedir)
    if not os.path.exists(cachelink):
        os.symlink(cachedir, cachelink)
else:
    if os.path.islink(cachelink):
        os.unlink(cachelink)
    make_dir(cachelink)

if not os.path.exists(cachelink):
    os.symlink(ABSROOTDIR+"/.radiopadre", cachelink)


JUPYTER_OPTS = [
    "notebook",
    "--ContentsManager.pre_save_hook=radiopadre_utils.notebook_utils._notebook_save_hook",
    "--ContentsManager.allow_hidden=True" ]

DEVZERO = open("/dev/zero")
DEVNULL = open("/dev/null", "w")

activation_script = os.path.join(PADRE_VENV, "bin/activate_this.py")
complete_cookie = os.path.join(PADRE_VENV, ".complete")

# Switch into virtualenv, unless we're using docker
if not options.docker:
    # See https://stackoverflow.com/questions/1871549/determine-if-python-is-running-inside-virtualenv
    if hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix):
        if sys.prefix == PADRE_VENV:
            message("Already running inside radiopadre virtual environment")
        else:
            bye("Can't run this script inside a non-radiopadre virtualenv. Please deactivate and rerun.")
    else:
        if os.path.exists(activation_script) and os.path.exists(complete_cookie) and not options.reinstall:
            message("Found radiopadre virtualenv in {PADRE_VENV}")
        elif options.bootstrap or options.reinstall:
            if options.reinstall:
                message("Will reinstall radiopadre virtualenv using install-radiopadre")
            else:
                message("Can't find complete radiopadre virtualenv, bootstrapping with install-radiopadre")
            if shell("{}/bin/install-radiopadre {} {} reinstall".format(PADRE_PATH,
                        "--no-casacore" if options.no_casacore else "",
                        "--no-js9" if options.no_js9 else "",
                    )):
                bye("Installation script failed")

        message("Activating the radiopadre virtualenv via {activation_script}")
        execfile(activation_script, dict(__file__=activation_script))

message("Welcome to Radiopadre!")
if options.docker:
    docker_image = options.docker_image
    if docker_image[0] == ":":
        docker_image = DEFAULT_DOCKER_IMAGE.split(":")[0] + docker_image
    message("  Using radiopadre Docker image {docker_image}")
    if options.docker_pull:
        message("  Calling docker pull to make sure the image is up-to-date.")
        message("  (This may take a few minutes if it isn't....)")
        subprocess.call("docker pull {}".format(docker_image), shell=True)

elif options.inside_container:
    message("  Running inside a container")
else:
    message("  Using radiopadre install at {PADRE_PATH}")
message("  Session ID/notebook token is '{}'".format(session_id))  # careful, this is read by run-remote-padre!

# directory where we were originally run
os.environ['RADIOPADRE_ABSROOTDIR'] = ABSROOTDIR

# check if a root directory needs to be faked
# if not, make .radiopadre workdir
if os.access(ROOTDIR, os.W_OK):
    os.environ['RADIOPADRE_SERVER_BASEDIR'] = ABSROOTDIR
    orig_rootdir = None
else:
    message("  Target is {ROOTDIR}, which is not user-writeable. Will use a shadow directory instead.")
    message("  Shadow directory is {SHADOWDIR}")
    orig_rootdir = ROOTDIR
    os.environ['RADIOPADRE_SERVER_BASEDIR'] = ROOTDIR = SHADOWDIR
    os.chdir(SHADOWDIR)

make_dir(".radiopadre")


#=== will we be starting a browser?

browser = False
if options.inside_container:
    message("  Running inside container -- not opening a browser")
elif os.environ.get("SSH_CLIENT"):
    message("You appear to have logged in via ssh")
    if options.browser:
        message("--browser is set so I will open a browser anyway")
        browser = True
    else:
        message("You're logged in via ssh, so I'm not opening a web browser for you.")
        message("Please manually browse to the URL printed by Jupyter below. You will probably want to employ ssh")
        message("port forwarding if you want to browse this notebook from your own machine.")
        browser = False
else:
    message("You appear to have a local session")
    if options.no_browser:
        message("--no-browser is set, jupyter notebook will not invoke a browser.")
        message("Please manually browse to the URL printed by Jupyter below.")
        browser = False
    else:
        message("Allowing jupyter notebook to open a web browser. Use --no-browser to disable this.")
        browser = True


#=== find unused ports for Jupyter & helpers

def find_unused_port (base,maxtries=1000):
    for i in range(maxtries):
        serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            serversocket.bind(("localhost", base))
            serversocket.close()
            return base
        except:
            base += 1
            continue
    return None

if options.inside_container:
    jupyter_port, helper_port, http_port = CONTAINER_PORTS
    message("Inside container, using fixed ports {} {} {}".format(jupyter_port, helper_port, http_port))
else:
    jupyter_port = find_unused_port(1024)
    helper_port  = find_unused_port(jupyter_port+1)
    http_port    = find_unused_port(helper_port+1)
    selected_ports = jupyter_port, helper_port, http_port
    message("Selected ports: {}:{}:{}".format(jupyter_port, helper_port, http_port))

# in remote mode, ask the user-side script to supply port numbers
# (these need to be given to radiopadre so it can form up paths properly)
if options.remote:
    forwarded_ports = raw_input("{Remote mode} please enter fowarded port numbers: ")
    userside_jupyter_port, userside_helper_port, userside_http_port = forwarded_ports.strip().split(" ", 2)
    # print userside_helper_port, userside_http_port
# if inside container, the userside port numbers are passed in as via --inside-container port1:port2
elif options.inside_container:
    userside_jupyter_port, userside_helper_port, userside_http_port = map(int, options.inside_container.split(":"))
# else running locally -- userside port are as is
else:
    userside_jupyter_port, userside_helper_port, userside_http_port = jupyter_port, helper_port, http_port


JUPYTER_OPTS += [
    "--NotebookApp.token='{}'".format(session_id),
    "--NotebookApp.custom_display_url='http://localhost:{}'".format(userside_jupyter_port)
]

#=== figure out whether we initialize or load a notebook

ALL_NOTEBOOKS = glob.glob("*.ipynb")

if orig_rootdir and not ALL_NOTEBOOKS:
    orig_notebooks = glob.glob(os.path.join(orig_rootdir, "*.ipynb"))
    if orig_notebooks:
        message("  No notebooks in shadow directory, will copy notebooks from target.")
        message("  Copying {} notebooks from {}".format(len(orig_notebooks), orig_rootdir))
        for nb in orig_notebooks:
            shutil.copyfile(nb, './' + os.path.basename(nb))
        ALL_NOTEBOOKS = glob.glob("*.ipynb")

message("  Available notebooks: " + " ".join(ALL_NOTEBOOKS))

if not options.destination and not options.inside_container:

    DEFAULT_NAME = "radiopadre-default.ipynb"

    if not ALL_NOTEBOOKS:
        if not options.no_default:
            message("  No notebooks: will create {DEFAULT_NAME}")
            LOAD_DIR = True
            import shutil
            shutil.copyfile(PADRE_PATH + "/notebooks/" + DEFAULT_NAME, DEFAULT_NAME)
        else:
            message("  No notebooks but --no-default given. Displaying directory only.")
            LOAD_DIR = True
            LOAD_NOTEBOOK = None
    else:
        if LOAD_NOTEBOOK:
            if LOAD_NOTEBOOK in ALL_NOTEBOOKS:
                message("  Will load {LOAD_NOTEBOOK} as requested.")
            else:
                message("  {LOAD_NOTEBOOK} not found. Displaying directory only.")
                LOAD_DIR = True
                LOAD_NOTEBOOK = None
        else:
            if options.auto_load:
                LOAD_NOTEBOOK = ALL_NOTEBOOKS[0]
                message("  Auto-loading {LOAD_NOTEBOOK}.")


if LOAD_NOTEBOOK:
    message("Browse to URL: http://localhost:{}/notebooks/{}?token={}".format(
        userside_jupyter_port, LOAD_NOTEBOOK, session_id))  # this is read by remote
if LOAD_DIR:
    message("Browse to URL: http://localhost:{}/?token={}".format(userside_jupyter_port, session_id))

# now we're ready to start the container
if options.docker:
    docker = subprocess.check_output("which docker", shell=True).strip()
    if not docker:
        bye("docker binary not found")

    docker_local = make_dir("~/.radiopadre/.docker-local")
    js9_tmp = make_dir("~/.radiopadre/.js9-tmp")

    container_name = "radiopadre-{}".format(uuid.uuid4().hex)
    docker_opts = [ docker, "run", "-i", "--rm", "--name", container_name, "-w", ABSROOTDIR,
                        "--user", "{}:{}".format(os.getuid(), os.getgid()),
                        "-e", "USER={}".format(os.environ["USER"]),
                        "-e", "HOME={}".format(os.environ["HOME"])
                  ]
    for port1, port2 in zip(selected_ports, CONTAINER_PORTS):
        docker_opts += [ "-p", "{}:{}/tcp".format(port1, port2)]
    # setup mounts for work dir and home dir, if needed
    homedir = os.path.expanduser("~")
    docker_opts += [
                     "-v", "{}:{}{}".format(ABSROOTDIR, ABSROOTDIR, ":ro" if orig_rootdir else ""),
                     "-v", "{}:{}".format(homedir, homedir),
                     # hides /home/user/.local, which if exposed, can confuse jupyter and ipython
                     "-v", "{}:{}/.local".format(docker_local, homedir),
                     # mount a writeable tmp dir for the js9 install -- needed by js9helper
                     "-v", "{}:/.radiopadre/venv/js9-www/tmp".format(js9_tmp)
    ]
    if options.dev_docker:
        docker_opts += [ "-v", "{}:/radiopadre".format(PADRE_PATH) ]
    # add image
    docker_opts += [ docker_image,
                     "/radiopadre/bin/run-radiopadre",
                     "--inside-container", "{}:{}:{}".format(
                                userside_jupyter_port, userside_helper_port, userside_http_port),
                     "--workdir", PADRE_WORKDIR,
                   ]
    # add arguments
    if options.verbose:
        docker_opts.append("--verbose")
    if options.no_default:
        docker_opts.append("--no-default")
    if options.destination:
        docker_opts.append(options.destination)

    message("Running {}".format(" ".join(docker_opts)))
    message("  (If the image is not yet available locally, this can take a few minutes the first time you run.)")
    docker_process = subprocess.Popen(docker_opts,
                                      stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                      env=os.environ)

    # print session ID to script in container, as it expects it
    docker_process.stdin.write(session_id+"\n")


    # now go through this whole rigamarole of waiting for the container to report the notebook is started...
    import select
    poller = select.poll()
    poller.register(docker_process.stdout)
    poller.register(docker_process.stderr)
    fdlabels = { docker_process.stdout.fileno(): ("stdout", docker_process.stdout),
                 docker_process.stderr.fileno(): ("stderr", docker_process.stderr) }

    try:
        while True:
            fdlist = poller.poll()
            for fd, event in fdlist:
                if event & (select.POLLHUP | select.POLLERR):
                    break
                fname, fobj = fdlabels.get(fd)
                line = fobj.readline().strip()
                message("docker {}: {}".format(fname, line))
                if "Jupyter Notebook is running" in line:
                    # report URL back to remote
                    # start browser if requested
                    if browser:
                        message("notebook startup detected -- driving browser")
                        default_browser = os.environ.get("PADRE_BROWSER", "xdg-open")
                        if LOAD_NOTEBOOK:
                            subprocess.Popen([default_browser,
                                              "http://localhost:{}/notebooks/{}?token={}".format(jupyter_port, LOAD_NOTEBOOK, session_id)])
                        else:
                            subprocess.Popen([default_browser,
                                              "http://localhost:{}/?token={}".format(jupyter_port, session_id)])
    except BaseException as exc:
        if type(exc) is KeyboardInterrupt:
            message("Caught Ctrl+C, terminating docker processes -- give it a few seconds")
        else:
            message("Caught exception {}, terminating docker processes -- give it a few seconds".format(exc))
        docker_process.terminate()
        docker_process.wait()
        status = 1

    # try:
    #     # give the docker process the session ID
    #     docker_process.communicate(session_id+"\n\n\n")
    #     status = 0
    # except Exception as exc:
    #     message("Caught exception {}, terminating docker processes".format(exc))
    #     docker_process.terminate()
    #     docker_process.wait()
    #     status = 1

    if container_name in subprocess.check_output(["docker", "ps"]):
        message("Cleaning up container")
        try:
            subprocess.check_output(["docker", "rm", container_name, "--force"])
        except subprocess.CalledProcessError:
            pass
    message("Exiting")
    sys.exit(status)


# get hostname
os.environ["HOSTNAME"] = subprocess.check_output("/bin/hostname")

# get jupyter path
notebook_dir = subprocess.check_output("{PADRE_VENV}/bin/pip show jupyter| "
                                       "grep Location:|cut -d ':' -f 2".format(**globals()), shell=True).strip()
if not notebook_dir:
    raise subprocess.CalledProcessError("jupyter installation path not found")


# check status of JS9. Ends up being True, or a RuntimeError

js9dir = js9error = None
js9status_file = PADRE_VENV + "/js9status"
if not os.path.exists(js9status_file):
    js9error = "not found"
else:
    js9dir = open(js9status_file).read().strip()
    if not js9dir.startswith("/"):
        js9error = js9dir
        js9dir = None

os.environ['RADIOPADRE_JS9_DIR'] = js9dir or ''
os.environ['RADIOPADRE_JS9_ERROR'] = js9error or ''
if js9dir:
    message("  Found JS9 install in {js9dir}")
else:
    message("  Warning: JS9 not functional ({js9error}). Reinstall radiopadre?")


# # make link to JS9 install
# if js9dir:
#     if not os.path.exists(PADRE_WORKDIR + "/js9-www"):
#         os.symlink(js9dir, PADRE_WORKDIR + "/js9-www")
#     if not os.path.exists(PADRE_WORKDIR + "/js9colormaps.js"):
#         message("making {} symlink".format(PADRE_WORKDIR + "/js9colormaps.js"))
#         os.symlink(notebook_dir + "/notebook/static/js9colormaps.js", PADRE_WORKDIR + "/js9colormaps.js")
#     if not os.path.exists(PADRE_WORKDIR + "/radiopadre-www"):
#         os.symlink(PADRE_PATH + "/html", PADRE_WORKDIR + "/radiopadre-www")

# add padre directory to PYTHONPATH
if "PYTHONPATH" in os.environ:
    os.environ["PYTHONPATH"] = os.environ["PYTHONPATH"] + ":" + PADRE_PATH
else:
    os.environ["PYTHONPATH"] = PADRE_PATH



JUPYTER_OPTS.append("--port={}".format(jupyter_port))
if not browser:
    JUPYTER_OPTS += ["--no-browser", "--browser=/dev/null"] # --no-browser alone seems to be ignored

if options.inside_container:
    JUPYTER_OPTS += ["--allow-root", "--ip=0.0.0.0"] # --no-browser alone seems to be ignored

if LOAD_NOTEBOOK:
    JUPYTER_OPTS.append(LOAD_NOTEBOOK)

#os.environ['RADIOPADRE_SHADOW_URLBASE'] = urlbase = "http://localhost:{}/".format(forwarded_http_port)
os.environ['RADIOPADRE_SHADOW_URLBASE'] = urlbase = "http://localhost:{}/{}/".format(userside_http_port, session_id)
js9prefs = None

http_rewrites = [ "/radiopadre-www/={}/".format(PADRE_PATH + "/html") ]

if js9dir:
    os.environ['RADIOPADRE_JS9_HELPER_PORT'] = str(userside_helper_port)
    # create JS9 settings file for session
    js9prefs = ".radiopadre/js9prefs.js"
    open(js9prefs, "w").write(
        "JS9Prefs.globalOpts.helperPort = {};\n".format(userside_helper_port)
    )
    # URL to local settings file for this session
    os.environ['RADIOPADRE_JS9_DIR'] = "{}js9-www/".format(urlbase)
    os.environ['RADIOPADRE_JS9_SETTINGS'] = "{}{}/{}".format(urlbase, ABSROOTDIR.lstrip("/"), js9prefs)


    http_rewrites.append("/js9-www/={}/".format(js9dir))
    http_rewrites.append("/js9colormaps.js={}".format(notebook_dir + "/notebook/static/js9colormaps.js"))

try:
    helper_proc = None
    if js9dir:
        os.environ['JS9_LOCAL_URL_PREFIX'] = urlbase
        os.environ['JS9_LOCAL_FS_PREFIX'] = PADRE_WORKDIR + "/"
        js9helper = js9dir +"/js9Helper.js"
        if os.path.exists(js9helper):
            message("Starting {js9helper} on port {helper_port} in {SHADOWDIR}")
            try:
                nodejs = subprocess.check_output("which nodejs || which node", shell=True)
            except subprocess.CalledProcessError:
                nodejs = None
                bye("Unable to find nodejs or node -- can't run js9helper. You need to apt-get install nodejs perhaps?")
            try:
                os.chdir(SHADOWDIR)
                child_processes.append(subprocess.Popen([nodejs.strip(), js9helper,
                    ('{{"helperPort": {}, "debug": {}, ' +
                     '"fileTranslate": ["^(http://localhost:[0-9]+/[0-9a-f]+{}|/static/)", ""] }}').format(
                        helper_port, 1 if options.verbose else 0,
                        ABSROOTDIR)],
                    stdin=DEVZERO, stdout=sys.stdout, stderr=sys.stderr))
            finally:
                os.chdir(ROOTDIR)

    message("Starting HTTP server process in {PADRE_WORKDIR} on port {http_port}")
    args = [PADRE_VENV+"/bin/python", PADRE_PATH+"/bin/http_server.py", str(http_port) ] + http_rewrites

    try:
        os.chdir(PADRE_WORKDIR)
        child_processes.append(subprocess.Popen(args, stdin=DEVZERO,
                      stdout=sys.stdout if options.verbose else DEVNULL,
                      stderr=sys.stderr if options.verbose else DEVNULL))
    finally:
        os.chdir(ROOTDIR)

    ## start jupyter process

    jupyter_path = PADRE_VENV + "/bin/jupyter"
    message("Starting: "+jupyter_path+" "+" ".join(JUPYTER_OPTS))

    notebook_proc = subprocess.Popen([jupyter_path] + JUPYTER_OPTS,
                                      stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
                                      env=os.environ)

    ## use this instead to debug the sessison
    #notebook_proc = subprocess.Popen([PADRE_VENV+"/bin/ipython"],
    #                                 stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr,
    #                                  env=os.environ)

    child_processes.append(notebook_proc)

    notebook_proc.wait()
    message("Notebook process done")
    child_processes.pop(-1)

finally:
    message("Terminating child processes")
    for proc in child_processes:
        proc.terminate()
        proc.wait()

message("Exiting")